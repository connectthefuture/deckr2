package deckr;

// START CLIENT MESSAGES

// Union for all deckr messages that can be sent by the client
// and recieved by the server
// Next field: 5
message ClientMessage {
    enum ClientMessageTypes {
        CREATE = 0;
        JOIN = 1;
        ACTION = 2;
        LEAVE = 3;
        QUIT = 4;

    }
    required ClientMessageTypes message_type = 1;

    optional CreateMessage create_message = 2;
    optional JoinMessage join_message = 3;
    optional ActionMessage action_message = 4;
    // Note that leave and quit have no arguments so there's no data for them.
}

// Next Field: 3
message CreateMessage {
    optional string variant = 1;
    optional int32 max_players = 2;
}

// Next Field: 4
message JoinMessage {

    enum ClientType {
        PLAYER = 0;
        SPECTATOR = 1;
    }

    message PlayerConfig { }

    required string game_id = 1;
    required ClientType client_type = 2;
    optional PlayerConfig player_config = 3;
}

// This is the union of possible actions
// Next Field: 6
message ActionMessage {
    enum ActionType {
        START = 0;
        PLAY = 1;
        ACTIVATE = 2;
        DECLARE_ATTACKERS = 3;
        DECLARE_BLOCKERS = 4;
        PASS_PRIORITY = 5;
    }

    required ActionType action_type = 1;

    optional PlayAction play = 2;
    optional ActivateAction activate_ability = 3;
    optional DeclareAttackersAction declare_attackers = 4;
    optional DeclareBlockersAction declare_blockers = 5;
}

// START SERVER RESPONSES

// Collection of all messages that can be sent by the server to
// the client.
// Next Field: 4
message ServerResponse {
    enum ServerResponseType {
        CREATE = 0;
        JOIN = 1;
        LEAVE = 2;
        ERROR = 3;
    }

    required ServerResponseType response_type = 1;

    optional CreateResponse create_response = 2;
    optional ErrorResponse error_response = 3;
}

// Next Field: 2
message CreateResponse {
    required string game_id = 1;
}

// Next Field: 2
message ErrorResponse {
    required string message = 1;
}

// START GAME_ACTIONS

// Next Field: 2
message PlayAction {
    required GameObject card = 1;
}

// Next Field: 3
message ActivateAction {
    required GameObject card = 1;
    required int32 index = 2;
}


// Next Field: 2
message DeclareAttackersAction {
    message AttackerMapping {
        required GameObject attacker = 1;
        required GameObject target = 2;
    }
    repeated AttackerMapping attackers = 1;
}

// Next Field: 2
message DeclareBlockersAction {
    message BlockerMapping {
        required GameObject blocker = 1;
        required GameObject blocking = 2;
    }
    repeated BlockerMapping blockers = 1;
}

// Next Field: 2
message GameObject {
    required int32 game_id = 1;
}
